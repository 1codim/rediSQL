{
    "docs": [
        {
            "location": "/",
            "text": "RediSQL\n\n\nRediSQL is a redis module that embed a fully functional SQLite database.\n\n\nMotivation\n\n\nThe main motivation behind the project is to provide a quick and hands-off environment to store structured data.\n\n\nIt also turns out that RediSQL is a great way to cache your content and data in a more structured way.\n\n\nSusteinable Open Source\n\n\nThe project is based on the idea of susteinable Open Source.\n\n\nThe project provides two versions, an open source one, which is enough for most simple projects, and a PRO version that provide features required from companies and enterprises.\n\n\nOverview\n\n\nIn this section we are going to explore the main concepts in the module.\n\n\nThere is another section of the website, \nthe reference\n, that explore every single command that the module provides giving deeper explaination of every detail.\n\n\nDatabases\n\n\nRediSQL provide the concept of database.\n\n\nIt is possible to create a new database with the command \nREDISQL.CREATE_DB\n.\n\n\nThe database get associate with a Redis key and so it is possible to have multiple SQL databases in a single Redis instance.\n\n\nAlso it is possible to use in-memory database, wich is the default, or databases backed by a real file. In-memory databases are generally a little faster but they are limited by the ammount of memory your server has. Database backed by files are a little slower but they can grow basically indefinitely.\n\n\nExec\n\n\nREDISQL.EXEC\n is the command that let you execute command against a SQL database.\n\n\nIt is usefull when you are testing the module or when you are changing the settings of the databases throught SQLite \nPRAGMA\ns.\n\n\nHowever I would not suggest to use them in production since there are better tools like \nStatements\n.\n\n\nStatements\n\n\nQueries and stataments can be precompile and stores inside the Redis key in order to provide a faster execution and more agility in your application.\n\n\nWhen you execute a SQLite query, the text is compiled to a binary code, this binary code is then executed against the database and the result provide as answer.\nThe phase of compilation can be quite expensive, but if you always execute the same statements (think about \ninserts\n), it can be avoided.\n\n\nWhen you use \nREDISQL.CREATE_STATEMENT\n your statement get compiled, then when you execute it using \nREDISQL.EXEC_STATEMENT\n it is not re-compiled but we use the pre-compiled one. It seems a trivial change but it will really speed up some workload.\n\n\nStatements can also be used as an interface for different application using the same RediSQL instance.\n\n\nOnce you define the interface of the statement and its behavior, then you are free to change it's implementation  while maintain all the legacy code working.\nThis is quite useful esepcially if you have several services using the same RediSQL instance.\n\n\nPersistency\n\n\nThe module in the community version implements only RDB. However the PRO version provide also AOF and replication.\n\n\nRDB\n\n\nThe module implements RDB persistency.\n\n\nWhen Redis starts to save the RDB file the status of the database get serialized and written, along with all the other information, in the RDB file.\n\n\nAOF\n\n\nAOF replication is provided only in the PRO edition.\n\n\nAt the moment all the commands are replicated, this is quite a waste and we are moving to replicate only the commands that actually modify the codebase.\n\n\nWith AOF replication you also get instance replication that allows to replicate the same dataset into different redis instances.",
            "title": "Overview"
        },
        {
            "location": "/#redisql",
            "text": "RediSQL is a redis module that embed a fully functional SQLite database.",
            "title": "RediSQL"
        },
        {
            "location": "/#motivation",
            "text": "The main motivation behind the project is to provide a quick and hands-off environment to store structured data.  It also turns out that RediSQL is a great way to cache your content and data in a more structured way.",
            "title": "Motivation"
        },
        {
            "location": "/#susteinable-open-source",
            "text": "The project is based on the idea of susteinable Open Source.  The project provides two versions, an open source one, which is enough for most simple projects, and a PRO version that provide features required from companies and enterprises.",
            "title": "Susteinable Open Source"
        },
        {
            "location": "/#overview",
            "text": "In this section we are going to explore the main concepts in the module.  There is another section of the website,  the reference , that explore every single command that the module provides giving deeper explaination of every detail.",
            "title": "Overview"
        },
        {
            "location": "/#databases",
            "text": "RediSQL provide the concept of database.  It is possible to create a new database with the command  REDISQL.CREATE_DB .  The database get associate with a Redis key and so it is possible to have multiple SQL databases in a single Redis instance.  Also it is possible to use in-memory database, wich is the default, or databases backed by a real file. In-memory databases are generally a little faster but they are limited by the ammount of memory your server has. Database backed by files are a little slower but they can grow basically indefinitely.",
            "title": "Databases"
        },
        {
            "location": "/#exec",
            "text": "REDISQL.EXEC  is the command that let you execute command against a SQL database.  It is usefull when you are testing the module or when you are changing the settings of the databases throught SQLite  PRAGMA s.  However I would not suggest to use them in production since there are better tools like  Statements .",
            "title": "Exec"
        },
        {
            "location": "/#statements",
            "text": "Queries and stataments can be precompile and stores inside the Redis key in order to provide a faster execution and more agility in your application.  When you execute a SQLite query, the text is compiled to a binary code, this binary code is then executed against the database and the result provide as answer.\nThe phase of compilation can be quite expensive, but if you always execute the same statements (think about  inserts ), it can be avoided.  When you use  REDISQL.CREATE_STATEMENT  your statement get compiled, then when you execute it using  REDISQL.EXEC_STATEMENT  it is not re-compiled but we use the pre-compiled one. It seems a trivial change but it will really speed up some workload.  Statements can also be used as an interface for different application using the same RediSQL instance.  Once you define the interface of the statement and its behavior, then you are free to change it's implementation  while maintain all the legacy code working.\nThis is quite useful esepcially if you have several services using the same RediSQL instance.",
            "title": "Statements"
        },
        {
            "location": "/#persistency",
            "text": "The module in the community version implements only RDB. However the PRO version provide also AOF and replication.",
            "title": "Persistency"
        },
        {
            "location": "/#rdb",
            "text": "The module implements RDB persistency.  When Redis starts to save the RDB file the status of the database get serialized and written, along with all the other information, in the RDB file.",
            "title": "RDB"
        },
        {
            "location": "/#aof",
            "text": "AOF replication is provided only in the PRO edition.  At the moment all the commands are replicated, this is quite a waste and we are moving to replicate only the commands that actually modify the codebase.  With AOF replication you also get instance replication that allows to replicate the same dataset into different redis instances.",
            "title": "AOF"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nThis documents explains all the API that RediSQL provide to the users.\n\n\nFor each command it expose first the name and then the syntaxt and finally a brief explaination of what is going on inside the code.\n\n\nWhere is possible it provides also an estimate of the complexity, since we are talkings about databases not al queries have the same time and spatial complexity.\n\n\nFinaly, if it is appropriate the document also provide several references to external material that the interested reader can use to understand better the dynamics of every and each command.\n\n\nREDISQL.CREATE_DB\n\n\nREDISQL.CREATE_DB db_key [path]\n\n\nThis command create a new DB and associate it with the key.\n\n\nThe path arguments is optional and, if provide is the file that SQLite will use.\nIt can be an exixsting SQLite file or it can be a non exixsting file.\n\n\nIf the file actually exists and if it is a regular SQLite file that database will be used.\nIf the file does not exists a new file will be created.\n\n\nIf the path is not provide it will open an in memory database. Not providing a path is equivalent to provide the special string \n:memory:\n as path argument.\n\n\nAfter opening the database it inserts metadata into it and then starts a thread loop.\n\n\nComplexity\n: O(1), it means constant, it does not necessarly means \nfast\n. However is fast enough for any use case facing human users (eg create a new databse for every user loggin in a website.)\n\n\nSee also\n: \n\n\n\n\nSQLite \nsqlite3_open_v2\n\n\n\n\nDEL\n\n\nDEL db_key [key ...]\n\n\nThis command is a generic command from Redis.\n\n\nIt eliminates keys from Redis itself, as well if the key is a RediSQL database create with \nREDISQL.CREATE_DB\n it will eliminate the SQLite database, stop the thread loop and clean up everything left.\n\n\nIf the database is backed by a file the file will be close.\n\n\nComplexity\n: DEL is O(N) on the number of keys, if you are only eliminating the key associated with the SQLite database will be constant, O(1).\n\n\nSee also\n: \n\n\n\n\nSQLite \nsqlite3_close\n\n\nRedis \nDEL\n\n\n\n\nREDISQL.EXEC\n\n\nREDISQL.EXEC db_key \"statement\"\n\n\nThis command takes as input a redis key created with \nREDISQL.CREATE_DB\n and a statement string.\n\n\nInternally it transform the string into a \nsqlite statement\n using \nsqlite3_prepare_v2\n, execute it against the database, \nsqlite3_step\n, and finally returns the results to the client.\n\n\nThe compilation of the string into a statement and its execution happens in a different therad from the one used by redis and so this command has a minimum impact on the overall Redis performance, however it does block the client.\n\n\nThis command is quite useful to execute \nPRAGMA Statements\n, for normal operations against the database is suggested to use \nSTATEMENTS\n.\n\n\nAlso, remember that there is only a single thread for database, execution of multiple \nREDISQL.EXEC\n against the same database will result in a serialization of the executions, one will be executed before the others.\n\n\nFinally is importat to have in mind how \nsqlite3_prepare_v2\n works. The functions compile only the first statement, (everything between the start of the string and the first semicolon \n;\n) and not the whole string. This means that executing commands like:\n\n\nBEGIN TRANSACTION; -- here first semicolon, and first statement\nINSERT INTO ... ;\nSELECT n FROM ...;\nCASE \n  WHEN n >= 4 THEN ABORT\n  ELSE COMMIT\nEND;\n\n\n\n\nWill \nNOT\n, let me repeat, it will \nnot\n work as expected, the first statement is just \nBEGIN TRANSACTION;\n and only that one will be executed.\n\n\nPlease note that we are seriously considering to change this behaviour in order to make transactions and other queries works in the expected way.\n\n\nComplexity\n: It depends interally on the statement string. The use of a single thread for database is been choosen after several tests where the single thread configuration was faster than a multi thread one. This is true in a write intensive application and in a mixed write/read application.\n\n\nSee also\n:\n\n\n\n\nSQLite \nsqlite3_prepare_v2\n\n\nSQLite \nstatement\n aka \nsqlite3_stmt\n\n\nSQLite \nsqlite3_step\n\n\nSQLite \nPRAGMA\ns\n\n\nRedis Blocking Command\n\n\n\n\nREDISQL.CREATE_STATEMENT\n\n\nREDISQL.CREATE_STATEMENT db_key stmt_identifier \"statement\"\n\n\nThis command compile a statement string into an \nsqlite statement\n and associate such statement to an identifier.\n\n\nThe same limitation of \nREDISQL.EXEC\n regarding multiple statements in the same string. Only the first SQL statement (from the beginning to the first semicolon \n;\n) get compiled into an sqlite statement.\n\n\nUsing this command you can insert parameters using the \n?\n special sysmbols, those parameters will be bind to the statements when you are executing the statement itself.\n\n\nFor now only the \n?\n syntax is supported.\n\n\nThis command does not execute anything against the database, but simply store the sqlite statements into a dictionary associated with the identifier provided (\nstmt_identifier\n). Then it stores the information regarding the statement into the metadata table in order to provide a simple way to restore also the statements.\n\n\nThe statement is associated with a database, a statement created for one database cannot be used for another database, you need to create a different one. This allow a simple and fast way to provide persistency.\n\n\nYou can execute the statement with \nREDISQL.EXEC_STATEMENT\n.\n\n\nYou cannot overwrite a statement, however you can delete an old one, using \nREDISQL.DELETE_STATEMENT\n and then create a new one with the same name, this in order to avoid error while creating statements. \nSuppose that a service need a particular statement to be define in order to work, this safety measure allow the users to simply go ahead, try to create it, and in case catch the error.\n\n\nAlso this command is not blocking, meaning that all the work happens in a separate thread respect the redis one.\n\n\nComplexity\n: If we assume that the time necessary to compile a string into a sqlite statement is constant, overall the complexity is O(1), again constant, not necessarly \nfast\n.\n\n\nSee also\n:\n\n\n\n\nSQLite \nsqlite3_prepare_v2\n\n\nSQLite \nstatement\n aka \nsqlite3_stmt\n\n\nSQLite bindings, \nsqlite3_bind_text\n\n\nREDISQL.EXEC_STATEMENT\n\n\nREDISQL.DELETE_STATEMENT\n\n\nRedis Blocking Command\n\n\n\n\nREDISQL.EXEC_STATEMENT\n\n\nREDISQL.EXEC_STATEMENT db_key stmt_identifier [binding_parameters ...]\n\n\nThis command binds all the parameters to the statement created using \nREDISQL.CREATE_STATEMENT\n and identifed by \nstmt_identifier\n. Then the module execute the statement against the db associate to \ndb_key\n.\n\n\nThe number of parameters must be coherent with the number expected by the statement, if there were 3 \n?\n you need to provide 3 binding parameters.\nThe bindings are associated in order to the statement.\n\n\nRedis works using a text protocol, all the arguments are encoded as text, hence the module is forced to use the procedure \nsqlite3_bind_text\n, however SQLite is smart enough to recognize numbers and treat them correctly. Numbers will be threat as numbers, text will be treat as text.\n\n\nFinally, once completed the binding part the statement is executed and its result is returned to the client.\n\n\nThis command as well is not blocking, all the work happens in a different thread from the one of Redis.\n\n\nComplexity\n: The complexity to retrieve and to bind the parameters is roughly constant for any practical purpose, however the overall complexity will be dominated by the time to execute the query.\n\n\nSee also\n:\n\n\n\n\nSQLite \nstatement\n aka \nsqlite3_stmt\n\n\nSQLite bindings, \nsqlite3_bind_text\n\n\nREDISQL.CREATE_STATEMENT\n\n\nRedis Blocking Command\n\n\n\n\nREDISQL.DELETE_STATEMENT\n\n\nREDISQL.DELETE_STATEMENT db_key stmt_identifier\n\n\nThis comand eliminates a statements from the db.\n\n\nIt first look remove it from an internal hash table and then remove it from an internal SQLite table.\n\n\nEliminating a statement first and then re-create one using the same identifier is the only way to change its implementation.\n\n\nAlso this command is not blocking and work in a different thread from the main Redis one.\n\n\nComplexity\n: The complexity is constant and fast.\n\n\nSee also\n:\n\n\n\n\nSQLite \nstatement\n aka \nsqlite3_stmt\n\n\nREDISQL.CREATE_STATEMENT\n\n\nREDISQL.EXEC_STATEMENT\n\n\nRedis Blocking Command",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "This documents explains all the API that RediSQL provide to the users.  For each command it expose first the name and then the syntaxt and finally a brief explaination of what is going on inside the code.  Where is possible it provides also an estimate of the complexity, since we are talkings about databases not al queries have the same time and spatial complexity.  Finaly, if it is appropriate the document also provide several references to external material that the interested reader can use to understand better the dynamics of every and each command.",
            "title": "References"
        },
        {
            "location": "/references/#redisqlcreate_db",
            "text": "REDISQL.CREATE_DB db_key [path]  This command create a new DB and associate it with the key.  The path arguments is optional and, if provide is the file that SQLite will use.\nIt can be an exixsting SQLite file or it can be a non exixsting file.  If the file actually exists and if it is a regular SQLite file that database will be used.\nIf the file does not exists a new file will be created.  If the path is not provide it will open an in memory database. Not providing a path is equivalent to provide the special string  :memory:  as path argument.  After opening the database it inserts metadata into it and then starts a thread loop.  Complexity : O(1), it means constant, it does not necessarly means  fast . However is fast enough for any use case facing human users (eg create a new databse for every user loggin in a website.)  See also :    SQLite  sqlite3_open_v2",
            "title": "REDISQL.CREATE_DB"
        },
        {
            "location": "/references/#del",
            "text": "DEL db_key [key ...]  This command is a generic command from Redis.  It eliminates keys from Redis itself, as well if the key is a RediSQL database create with  REDISQL.CREATE_DB  it will eliminate the SQLite database, stop the thread loop and clean up everything left.  If the database is backed by a file the file will be close.  Complexity : DEL is O(N) on the number of keys, if you are only eliminating the key associated with the SQLite database will be constant, O(1).  See also :    SQLite  sqlite3_close  Redis  DEL",
            "title": "DEL"
        },
        {
            "location": "/references/#redisqlexec",
            "text": "REDISQL.EXEC db_key \"statement\"  This command takes as input a redis key created with  REDISQL.CREATE_DB  and a statement string.  Internally it transform the string into a  sqlite statement  using  sqlite3_prepare_v2 , execute it against the database,  sqlite3_step , and finally returns the results to the client.  The compilation of the string into a statement and its execution happens in a different therad from the one used by redis and so this command has a minimum impact on the overall Redis performance, however it does block the client.  This command is quite useful to execute  PRAGMA Statements , for normal operations against the database is suggested to use  STATEMENTS .  Also, remember that there is only a single thread for database, execution of multiple  REDISQL.EXEC  against the same database will result in a serialization of the executions, one will be executed before the others.  Finally is importat to have in mind how  sqlite3_prepare_v2  works. The functions compile only the first statement, (everything between the start of the string and the first semicolon  ; ) and not the whole string. This means that executing commands like:  BEGIN TRANSACTION; -- here first semicolon, and first statement\nINSERT INTO ... ;\nSELECT n FROM ...;\nCASE \n  WHEN n >= 4 THEN ABORT\n  ELSE COMMIT\nEND;  Will  NOT , let me repeat, it will  not  work as expected, the first statement is just  BEGIN TRANSACTION;  and only that one will be executed.  Please note that we are seriously considering to change this behaviour in order to make transactions and other queries works in the expected way.  Complexity : It depends interally on the statement string. The use of a single thread for database is been choosen after several tests where the single thread configuration was faster than a multi thread one. This is true in a write intensive application and in a mixed write/read application.  See also :   SQLite  sqlite3_prepare_v2  SQLite  statement  aka  sqlite3_stmt  SQLite  sqlite3_step  SQLite  PRAGMA s  Redis Blocking Command",
            "title": "REDISQL.EXEC"
        },
        {
            "location": "/references/#redisqlcreate_statement",
            "text": "REDISQL.CREATE_STATEMENT db_key stmt_identifier \"statement\"  This command compile a statement string into an  sqlite statement  and associate such statement to an identifier.  The same limitation of  REDISQL.EXEC  regarding multiple statements in the same string. Only the first SQL statement (from the beginning to the first semicolon  ; ) get compiled into an sqlite statement.  Using this command you can insert parameters using the  ?  special sysmbols, those parameters will be bind to the statements when you are executing the statement itself.  For now only the  ?  syntax is supported.  This command does not execute anything against the database, but simply store the sqlite statements into a dictionary associated with the identifier provided ( stmt_identifier ). Then it stores the information regarding the statement into the metadata table in order to provide a simple way to restore also the statements.  The statement is associated with a database, a statement created for one database cannot be used for another database, you need to create a different one. This allow a simple and fast way to provide persistency.  You can execute the statement with  REDISQL.EXEC_STATEMENT .  You cannot overwrite a statement, however you can delete an old one, using  REDISQL.DELETE_STATEMENT  and then create a new one with the same name, this in order to avoid error while creating statements. \nSuppose that a service need a particular statement to be define in order to work, this safety measure allow the users to simply go ahead, try to create it, and in case catch the error.  Also this command is not blocking, meaning that all the work happens in a separate thread respect the redis one.  Complexity : If we assume that the time necessary to compile a string into a sqlite statement is constant, overall the complexity is O(1), again constant, not necessarly  fast .  See also :   SQLite  sqlite3_prepare_v2  SQLite  statement  aka  sqlite3_stmt  SQLite bindings,  sqlite3_bind_text  REDISQL.EXEC_STATEMENT  REDISQL.DELETE_STATEMENT  Redis Blocking Command",
            "title": "REDISQL.CREATE_STATEMENT"
        },
        {
            "location": "/references/#redisqlexec_statement",
            "text": "REDISQL.EXEC_STATEMENT db_key stmt_identifier [binding_parameters ...]  This command binds all the parameters to the statement created using  REDISQL.CREATE_STATEMENT  and identifed by  stmt_identifier . Then the module execute the statement against the db associate to  db_key .  The number of parameters must be coherent with the number expected by the statement, if there were 3  ?  you need to provide 3 binding parameters.\nThe bindings are associated in order to the statement.  Redis works using a text protocol, all the arguments are encoded as text, hence the module is forced to use the procedure  sqlite3_bind_text , however SQLite is smart enough to recognize numbers and treat them correctly. Numbers will be threat as numbers, text will be treat as text.  Finally, once completed the binding part the statement is executed and its result is returned to the client.  This command as well is not blocking, all the work happens in a different thread from the one of Redis.  Complexity : The complexity to retrieve and to bind the parameters is roughly constant for any practical purpose, however the overall complexity will be dominated by the time to execute the query.  See also :   SQLite  statement  aka  sqlite3_stmt  SQLite bindings,  sqlite3_bind_text  REDISQL.CREATE_STATEMENT  Redis Blocking Command",
            "title": "REDISQL.EXEC_STATEMENT"
        },
        {
            "location": "/references/#redisqldelete_statement",
            "text": "REDISQL.DELETE_STATEMENT db_key stmt_identifier  This comand eliminates a statements from the db.  It first look remove it from an internal hash table and then remove it from an internal SQLite table.  Eliminating a statement first and then re-create one using the same identifier is the only way to change its implementation.  Also this command is not blocking and work in a different thread from the main Redis one.  Complexity : The complexity is constant and fast.  See also :   SQLite  statement  aka  sqlite3_stmt  REDISQL.CREATE_STATEMENT  REDISQL.EXEC_STATEMENT  Redis Blocking Command",
            "title": "REDISQL.DELETE_STATEMENT"
        }
    ]
}